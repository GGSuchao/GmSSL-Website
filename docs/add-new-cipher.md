### 在GmSSL中添加新的对称加密算法

源代码的`demo`目录下准备了两个例子，分别是分组密码`mycipher`和序列密码(流密码)`mystream`。可以通过修改这两个例子来实现新算法。假设要实现分组密码是Serpent，一个尚未被GmSSL支持的常用分组密码，那么可以在`mycipher`的基础上修改。

首先将`mycipher`目录复制到`crypto`目录下，执行`make`，确定代码可以通过编译。然后将目录名、文件名、类型名和函数名中的`mycipher`都改为`serpent`，将宏定义的`MYCIPHER`改为`SERPENT`，具体的修改包括：

1. 修改目录`mycipher`的目录名。
2. 修改文件`mycipher.h`、`mycipher.c`和`myciphertest.c`的文件名
3. 修改`README.md`文件中的算法那信息。
4. 将`Makefile`和所有头文件、C文件中的`mycipehr`替换为`serpent`，`MYCIPHER`替换为`SERPENT`。

修改完成后再次运行`make`，如果编译通过，说明修改正确。然后可以开始在`serpent.c`文件中添加真正的实现了。

在算法的实现上有如下建议：

1. 尽量不要改动函数原型，如果算法需要更多的参数，也可以根据算法的规范添加。目前的函数都返回值为`void`，这意味着实现不需要对输入是否为空进行检查，并且实现也不应该以任何形式返回错误。
2. 不要在函数内部通过`malloc`等方式申请内存，`mycipher_key_t`的内部也不应该包含动态申请的内存。
3. 分组密码的加解密函数`mycipher_encrypt`和`mycipher_decrypt`每次调用时处理一个完整的分组，也就是说输入和输出的长度都应该是`MYCIPHER_BLOCK_SIZE`。
4. 序列密码提供的是一个加密函数而不是密钥序列生成函数，并且序列密码总是以字节为单位来加密数据的，因此对于`mystream_encrypt`，输入和输出的长度都等于参数`len`。要注意的是很多序列密码的密钥输出并不是以字节为单位的，对于这类算法那，因此实现中必须在`mystream_key_t`中维护一个内部的缓冲区，保证让`mystream_encrypt`能够以字节为单位进行数据处理。
5. 在测试文件`myciphertest.c`应该包含来自于标准文本的测试向量，并且代码能过通过测试。

在实现完成后再次运行`make`以确定编译通过。

然后开始检查测试向量，首先编译GmSSL，可以参考Wiki中的编译与安装。在Linux下在GmSSL根目录执行`./config`和`make`就可以了，便后后可以在根目录下得到`libcrypto.a`。然后编译测试代码：

```
cc -Wall serpent.c serpenttest.c ../../libcrypto.a
```

检查编译是否成功以及算法是否执行正确。

如果想把新算法并入GmSSL的主分支，还有以下的要求：

1. 代码能够通过编译和测试，证明算法的实现是正确的，并且不产生任何警告信息。
2. 提交的修改仅包括新算法的目录，不影响GmSSL的任意其他目录和文件。
3. 由于我们在维护GmSSL的时候代码不总是处于可成功编译的状态，或可以编译但是有明显错误，因此并不是随时同步到GitHub。因此提交前请和我们联系。我们通常在每周日提交新进展，并可能在周一做小的修正，因此周二是一个合并分支的好日子。

新的算法合并到GmSSL主分支后，我们会在EVP框架上增加对这个算法的支持，让应用可以通过EVP API和命令行工具访问这个算法。
